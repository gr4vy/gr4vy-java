/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.gr4vy.sdk.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.gr4vy.sdk.utils.LazySingletonValue;
import com.gr4vy.sdk.utils.Utils;
import java.lang.Boolean;
import java.lang.Long;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;

public class TransactionCreate {

    /**
     * The monetary amount for this transaction, in the smallest currency unit for the given currency, for example `1299` cents to create an authorization for `$12.99`. If the `intent` is set to `capture`, an amount greater than zero must be supplied. All gift card amounts are subtracted from this amount before the remainder is charged to the provided `payment_method`.
     */
    @JsonProperty("amount")
    private long amount;

    /**
     * A supported ISO 4217 currency code. For redirect requests, this value must match the one specified for `currency` in `payment_method`.
     */
    @JsonProperty("currency")
    private String currency;

    /**
     * The 2-letter ISO code of the country where the transaction is processed. This is also used to filter the payment services that can process the transaction. If this value is provided for redirect requests and it's not `null`, it must match the one specified for `country` in `payment_method`. Otherwise, the value specified for `country` in `payment_method` will be assumed implicitly.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("country")
    private JsonNullable<String> country;

    /**
     * The optional payment method to use for this transaction. This field is required if no `gift_cards` have been added.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payment_method")
    private JsonNullable<? extends TransactionCreatePaymentMethod> paymentMethod;

    /**
     * Guest buyer details provided inline rather than creating a buyer resource beforehand and using the `buyer_id` or `buyer_external_identifier` keys. No buyer resource will be created on Gr4vy when used.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("buyer")
    private JsonNullable<? extends GuestBuyerInput> buyer;

    /**
     * The ID of the buyer to associate this payment method to. If this field is provided then the `buyer_external_identifier` field needs to be unset. If a stored payment method or gift card is provided, then the buyer for that payment method needs to match the buyer for this field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("buyer_id")
    private JsonNullable<String> buyerId;

    /**
     * The `external_identifier` of the buyer to associate this payment method to. If this field is provided then the `buyer_id` field needs to be unset. If a stored payment method or gift card is provided, then the buyer for that payment method needs to match the buyer for this field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("buyer_external_identifier")
    private JsonNullable<String> buyerExternalIdentifier;

    /**
     * The optional gift card(s) to use for this transaction. At least one gift card is required if no other `payment_method` has been added. By default, only a maximum limit of 10 gift cards may be used in a single transaction. Please contact our team to change this limit.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("gift_cards")
    private JsonNullable<? extends List<GiftCardUnion>> giftCards;

    /**
     * An external identifier that can be used to match the transaction against your own records.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("external_identifier")
    private JsonNullable<String> externalIdentifier;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("intent")
    private Optional<? extends TransactionIntent> intent;

    /**
     * Whether or not to also try and store the payment method with us so that it can be used again for future use. This is only supported for payment methods that support this feature. There are also a few restrictions on how the flag may be set:
     * 
     * <p>* The flag has to be set to `true` when the `payment_source` is set to `recurring` or `installment`, and `merchant_initiated` is set to `false`.
     * * The flag has to be set to `false` (or not set) when using a previously vaulted payment method.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("store")
    private Optional<Boolean> store;

    /**
     * Pass through 3-D Secure data to support external 3-D Secure authorisation. If using an external 3-D Secure provider, you should not pass a `redirect_url` in the `payment_method` object for a transaction.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("three_d_secure_data")
    private JsonNullable<? extends ThreeDSecureData> threeDSecureData;

    /**
     * Any additional information about the transaction that you would like to store as key-value pairs. This data is passed to payment service providers that support it.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private JsonNullable<? extends Map<String, String>> metadata;

    /**
     * Indicates whether the transaction represents a subsequent payment coming from a setup recurring payment. Please note there are some restrictions on how this flag may be used.
     * 
     * <p>The flag can only be `false` (or not set) when the transaction meets one of the following criteria:
     * 
     * <p>* It is not `merchant_initiated`.
     * * `payment_source` is set to `card_on_file`.
     * 
     * <p>The flag can only be set to `true` when the transaction meets one of the following criteria:
     * * It is not `merchant_initiated`.
     * * `payment_source` is set to `recurring` or `installment` and `merchant_initiated` is set to `true`.
     * * `payment_source` is set to `card_on_file`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("is_subsequent_payment")
    private Optional<Boolean> isSubsequentPayment;

    /**
     * Indicates whether the transaction was initiated by the merchant (true) or customer (false).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("merchant_initiated")
    private Optional<Boolean> merchantInitiated;

    /**
     * The way payment method information made it to this transaction.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payment_source")
    private Optional<? extends TransactionPaymentSource> paymentSource;

    /**
     * The airline addendum data which describes the airline booking associated with this transaction.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("airline")
    private JsonNullable<? extends Airline> airline;

    /**
     * An array of cart items that represents the line items of a transaction.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cart_items")
    private JsonNullable<? extends List<CartItem>> cartItems;

    /**
     * Details about the payment and the merchant which may end up on the (bank) statement for the payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("statement_descriptor")
    private JsonNullable<? extends StatementDescriptor> statementDescriptor;

    /**
     * A scheme's transaction identifier to use in connecting a merchant initiated transaction to a previous customer initiated transaction. If not provided, and a qualifying customer initiated transaction has been previously made with the stored payment method, then Gr4vy will populate this value with the identifier returned for that transaction. This field is also know as the Visa Transaction Identifier, or Mastercard Trace ID.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("previous_scheme_transaction_id")
    private JsonNullable<String> previousSchemeTransactionId;

    /**
     * Information about the browser used by the buyer. This can be used by anti-fraud services.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("browser_info")
    private JsonNullable<? extends BrowserInfo> browserInfo;

    /**
     * The unique identifier of a set of shipping details stored for the buyer. If provided, the created transaction will include a copy of the details at the point of transaction creation; i.e. it will not be affected by later changes to the detail in the database.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shipping_details_id")
    private JsonNullable<String> shippingDetailsId;

    /**
     * Allows for passing optional configuration per connection to take advantage of connection specific features. When provided, the data is only passed to the target connection type to prevent sharing configuration across connections. Please note that each of the keys this object are in kebab-case, for example `cybersource-anti-fraud` as they represent the ID of the connector. All the other keys will be snake case, for example `merchant_defined_data` or camel case to match an external API that the connector uses.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("connection_options")
    private JsonNullable<? extends Map<String, Map<String, Object>>> connectionOptions;

    /**
     * Whether to capture the transaction asynchronously.
     * 
     * <p>- When `async_capture` is `false` (default), the transaction is captured in the same request.
     * - When `async_capture` is `true`, the transaction is automatically captured at a later time.
     * 
     * <p>Redirect transactions are not affected by this flag. This flag can only be set to `true` when `intent` is set to `capture`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("async_capture")
    private Optional<Boolean> asyncCapture;

    /**
     * This field represents the fingerprint data to be passed to the active anti-fraud service.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("anti_fraud_fingerprint")
    private JsonNullable<String> antiFraudFingerprint;

    /**
     * The unique identifier of an existing payment service. When provided, the created transaction will be processed by the given payment service and any routing rules will be skipped.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payment_service_id")
    private JsonNullable<String> paymentServiceId;

    /**
     * Marks the transaction as an AFT. Requires the payment service to support this feature, and might `recipient` and `buyer` data
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("account_funding_transaction")
    private Optional<Boolean> accountFundingTransaction;

    /**
     * Defines if the transaction will allow for a partial authorization.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("allow_partial_authorization")
    private Optional<Boolean> allowPartialAuthorization;

    /**
     * The recipient of any account to account funding. For use with AFTs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("recipient")
    private JsonNullable<? extends Recipient> recipient;

    /**
     * The number of installments a buyer is required to make.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("installment_count")
    private JsonNullable<Long> installmentCount;

    @JsonCreator
    public TransactionCreate(
            @JsonProperty("amount") long amount,
            @JsonProperty("currency") String currency,
            @JsonProperty("country") JsonNullable<String> country,
            @JsonProperty("payment_method") JsonNullable<? extends TransactionCreatePaymentMethod> paymentMethod,
            @JsonProperty("buyer") JsonNullable<? extends GuestBuyerInput> buyer,
            @JsonProperty("buyer_id") JsonNullable<String> buyerId,
            @JsonProperty("buyer_external_identifier") JsonNullable<String> buyerExternalIdentifier,
            @JsonProperty("gift_cards") JsonNullable<? extends List<GiftCardUnion>> giftCards,
            @JsonProperty("external_identifier") JsonNullable<String> externalIdentifier,
            @JsonProperty("intent") Optional<? extends TransactionIntent> intent,
            @JsonProperty("store") Optional<Boolean> store,
            @JsonProperty("three_d_secure_data") JsonNullable<? extends ThreeDSecureData> threeDSecureData,
            @JsonProperty("metadata") JsonNullable<? extends Map<String, String>> metadata,
            @JsonProperty("is_subsequent_payment") Optional<Boolean> isSubsequentPayment,
            @JsonProperty("merchant_initiated") Optional<Boolean> merchantInitiated,
            @JsonProperty("payment_source") Optional<? extends TransactionPaymentSource> paymentSource,
            @JsonProperty("airline") JsonNullable<? extends Airline> airline,
            @JsonProperty("cart_items") JsonNullable<? extends List<CartItem>> cartItems,
            @JsonProperty("statement_descriptor") JsonNullable<? extends StatementDescriptor> statementDescriptor,
            @JsonProperty("previous_scheme_transaction_id") JsonNullable<String> previousSchemeTransactionId,
            @JsonProperty("browser_info") JsonNullable<? extends BrowserInfo> browserInfo,
            @JsonProperty("shipping_details_id") JsonNullable<String> shippingDetailsId,
            @JsonProperty("connection_options") JsonNullable<? extends Map<String, Map<String, Object>>> connectionOptions,
            @JsonProperty("async_capture") Optional<Boolean> asyncCapture,
            @JsonProperty("anti_fraud_fingerprint") JsonNullable<String> antiFraudFingerprint,
            @JsonProperty("payment_service_id") JsonNullable<String> paymentServiceId,
            @JsonProperty("account_funding_transaction") Optional<Boolean> accountFundingTransaction,
            @JsonProperty("allow_partial_authorization") Optional<Boolean> allowPartialAuthorization,
            @JsonProperty("recipient") JsonNullable<? extends Recipient> recipient,
            @JsonProperty("installment_count") JsonNullable<Long> installmentCount) {
        Utils.checkNotNull(amount, "amount");
        Utils.checkNotNull(currency, "currency");
        Utils.checkNotNull(country, "country");
        Utils.checkNotNull(paymentMethod, "paymentMethod");
        Utils.checkNotNull(buyer, "buyer");
        Utils.checkNotNull(buyerId, "buyerId");
        Utils.checkNotNull(buyerExternalIdentifier, "buyerExternalIdentifier");
        Utils.checkNotNull(giftCards, "giftCards");
        Utils.checkNotNull(externalIdentifier, "externalIdentifier");
        Utils.checkNotNull(intent, "intent");
        Utils.checkNotNull(store, "store");
        Utils.checkNotNull(threeDSecureData, "threeDSecureData");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(isSubsequentPayment, "isSubsequentPayment");
        Utils.checkNotNull(merchantInitiated, "merchantInitiated");
        Utils.checkNotNull(paymentSource, "paymentSource");
        Utils.checkNotNull(airline, "airline");
        Utils.checkNotNull(cartItems, "cartItems");
        Utils.checkNotNull(statementDescriptor, "statementDescriptor");
        Utils.checkNotNull(previousSchemeTransactionId, "previousSchemeTransactionId");
        Utils.checkNotNull(browserInfo, "browserInfo");
        Utils.checkNotNull(shippingDetailsId, "shippingDetailsId");
        Utils.checkNotNull(connectionOptions, "connectionOptions");
        Utils.checkNotNull(asyncCapture, "asyncCapture");
        Utils.checkNotNull(antiFraudFingerprint, "antiFraudFingerprint");
        Utils.checkNotNull(paymentServiceId, "paymentServiceId");
        Utils.checkNotNull(accountFundingTransaction, "accountFundingTransaction");
        Utils.checkNotNull(allowPartialAuthorization, "allowPartialAuthorization");
        Utils.checkNotNull(recipient, "recipient");
        Utils.checkNotNull(installmentCount, "installmentCount");
        this.amount = amount;
        this.currency = currency;
        this.country = country;
        this.paymentMethod = paymentMethod;
        this.buyer = buyer;
        this.buyerId = buyerId;
        this.buyerExternalIdentifier = buyerExternalIdentifier;
        this.giftCards = giftCards;
        this.externalIdentifier = externalIdentifier;
        this.intent = intent;
        this.store = store;
        this.threeDSecureData = threeDSecureData;
        this.metadata = metadata;
        this.isSubsequentPayment = isSubsequentPayment;
        this.merchantInitiated = merchantInitiated;
        this.paymentSource = paymentSource;
        this.airline = airline;
        this.cartItems = cartItems;
        this.statementDescriptor = statementDescriptor;
        this.previousSchemeTransactionId = previousSchemeTransactionId;
        this.browserInfo = browserInfo;
        this.shippingDetailsId = shippingDetailsId;
        this.connectionOptions = connectionOptions;
        this.asyncCapture = asyncCapture;
        this.antiFraudFingerprint = antiFraudFingerprint;
        this.paymentServiceId = paymentServiceId;
        this.accountFundingTransaction = accountFundingTransaction;
        this.allowPartialAuthorization = allowPartialAuthorization;
        this.recipient = recipient;
        this.installmentCount = installmentCount;
    }
    
    public TransactionCreate(
            long amount,
            String currency) {
        this(amount, currency, JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined());
    }

    /**
     * The monetary amount for this transaction, in the smallest currency unit for the given currency, for example `1299` cents to create an authorization for `$12.99`. If the `intent` is set to `capture`, an amount greater than zero must be supplied. All gift card amounts are subtracted from this amount before the remainder is charged to the provided `payment_method`.
     */
    @JsonIgnore
    public long amount() {
        return amount;
    }

    /**
     * A supported ISO 4217 currency code. For redirect requests, this value must match the one specified for `currency` in `payment_method`.
     */
    @JsonIgnore
    public String currency() {
        return currency;
    }

    /**
     * The 2-letter ISO code of the country where the transaction is processed. This is also used to filter the payment services that can process the transaction. If this value is provided for redirect requests and it's not `null`, it must match the one specified for `country` in `payment_method`. Otherwise, the value specified for `country` in `payment_method` will be assumed implicitly.
     */
    @JsonIgnore
    public JsonNullable<String> country() {
        return country;
    }

    /**
     * The optional payment method to use for this transaction. This field is required if no `gift_cards` have been added.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<TransactionCreatePaymentMethod> paymentMethod() {
        return (JsonNullable<TransactionCreatePaymentMethod>) paymentMethod;
    }

    /**
     * Guest buyer details provided inline rather than creating a buyer resource beforehand and using the `buyer_id` or `buyer_external_identifier` keys. No buyer resource will be created on Gr4vy when used.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<GuestBuyerInput> buyer() {
        return (JsonNullable<GuestBuyerInput>) buyer;
    }

    /**
     * The ID of the buyer to associate this payment method to. If this field is provided then the `buyer_external_identifier` field needs to be unset. If a stored payment method or gift card is provided, then the buyer for that payment method needs to match the buyer for this field.
     */
    @JsonIgnore
    public JsonNullable<String> buyerId() {
        return buyerId;
    }

    /**
     * The `external_identifier` of the buyer to associate this payment method to. If this field is provided then the `buyer_id` field needs to be unset. If a stored payment method or gift card is provided, then the buyer for that payment method needs to match the buyer for this field.
     */
    @JsonIgnore
    public JsonNullable<String> buyerExternalIdentifier() {
        return buyerExternalIdentifier;
    }

    /**
     * The optional gift card(s) to use for this transaction. At least one gift card is required if no other `payment_method` has been added. By default, only a maximum limit of 10 gift cards may be used in a single transaction. Please contact our team to change this limit.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<GiftCardUnion>> giftCards() {
        return (JsonNullable<List<GiftCardUnion>>) giftCards;
    }

    /**
     * An external identifier that can be used to match the transaction against your own records.
     */
    @JsonIgnore
    public JsonNullable<String> externalIdentifier() {
        return externalIdentifier;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<TransactionIntent> intent() {
        return (Optional<TransactionIntent>) intent;
    }

    /**
     * Whether or not to also try and store the payment method with us so that it can be used again for future use. This is only supported for payment methods that support this feature. There are also a few restrictions on how the flag may be set:
     * 
     * <p>* The flag has to be set to `true` when the `payment_source` is set to `recurring` or `installment`, and `merchant_initiated` is set to `false`.
     * * The flag has to be set to `false` (or not set) when using a previously vaulted payment method.
     */
    @JsonIgnore
    public Optional<Boolean> store() {
        return store;
    }

    /**
     * Pass through 3-D Secure data to support external 3-D Secure authorisation. If using an external 3-D Secure provider, you should not pass a `redirect_url` in the `payment_method` object for a transaction.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<ThreeDSecureData> threeDSecureData() {
        return (JsonNullable<ThreeDSecureData>) threeDSecureData;
    }

    /**
     * Any additional information about the transaction that you would like to store as key-value pairs. This data is passed to payment service providers that support it.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Map<String, String>> metadata() {
        return (JsonNullable<Map<String, String>>) metadata;
    }

    /**
     * Indicates whether the transaction represents a subsequent payment coming from a setup recurring payment. Please note there are some restrictions on how this flag may be used.
     * 
     * <p>The flag can only be `false` (or not set) when the transaction meets one of the following criteria:
     * 
     * <p>* It is not `merchant_initiated`.
     * * `payment_source` is set to `card_on_file`.
     * 
     * <p>The flag can only be set to `true` when the transaction meets one of the following criteria:
     * * It is not `merchant_initiated`.
     * * `payment_source` is set to `recurring` or `installment` and `merchant_initiated` is set to `true`.
     * * `payment_source` is set to `card_on_file`.
     */
    @JsonIgnore
    public Optional<Boolean> isSubsequentPayment() {
        return isSubsequentPayment;
    }

    /**
     * Indicates whether the transaction was initiated by the merchant (true) or customer (false).
     */
    @JsonIgnore
    public Optional<Boolean> merchantInitiated() {
        return merchantInitiated;
    }

    /**
     * The way payment method information made it to this transaction.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<TransactionPaymentSource> paymentSource() {
        return (Optional<TransactionPaymentSource>) paymentSource;
    }

    /**
     * The airline addendum data which describes the airline booking associated with this transaction.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Airline> airline() {
        return (JsonNullable<Airline>) airline;
    }

    /**
     * An array of cart items that represents the line items of a transaction.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<CartItem>> cartItems() {
        return (JsonNullable<List<CartItem>>) cartItems;
    }

    /**
     * Details about the payment and the merchant which may end up on the (bank) statement for the payment.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<StatementDescriptor> statementDescriptor() {
        return (JsonNullable<StatementDescriptor>) statementDescriptor;
    }

    /**
     * A scheme's transaction identifier to use in connecting a merchant initiated transaction to a previous customer initiated transaction. If not provided, and a qualifying customer initiated transaction has been previously made with the stored payment method, then Gr4vy will populate this value with the identifier returned for that transaction. This field is also know as the Visa Transaction Identifier, or Mastercard Trace ID.
     */
    @JsonIgnore
    public JsonNullable<String> previousSchemeTransactionId() {
        return previousSchemeTransactionId;
    }

    /**
     * Information about the browser used by the buyer. This can be used by anti-fraud services.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<BrowserInfo> browserInfo() {
        return (JsonNullable<BrowserInfo>) browserInfo;
    }

    /**
     * The unique identifier of a set of shipping details stored for the buyer. If provided, the created transaction will include a copy of the details at the point of transaction creation; i.e. it will not be affected by later changes to the detail in the database.
     */
    @JsonIgnore
    public JsonNullable<String> shippingDetailsId() {
        return shippingDetailsId;
    }

    /**
     * Allows for passing optional configuration per connection to take advantage of connection specific features. When provided, the data is only passed to the target connection type to prevent sharing configuration across connections. Please note that each of the keys this object are in kebab-case, for example `cybersource-anti-fraud` as they represent the ID of the connector. All the other keys will be snake case, for example `merchant_defined_data` or camel case to match an external API that the connector uses.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Map<String, Map<String, Object>>> connectionOptions() {
        return (JsonNullable<Map<String, Map<String, Object>>>) connectionOptions;
    }

    /**
     * Whether to capture the transaction asynchronously.
     * 
     * <p>- When `async_capture` is `false` (default), the transaction is captured in the same request.
     * - When `async_capture` is `true`, the transaction is automatically captured at a later time.
     * 
     * <p>Redirect transactions are not affected by this flag. This flag can only be set to `true` when `intent` is set to `capture`.
     */
    @JsonIgnore
    public Optional<Boolean> asyncCapture() {
        return asyncCapture;
    }

    /**
     * This field represents the fingerprint data to be passed to the active anti-fraud service.
     */
    @JsonIgnore
    public JsonNullable<String> antiFraudFingerprint() {
        return antiFraudFingerprint;
    }

    /**
     * The unique identifier of an existing payment service. When provided, the created transaction will be processed by the given payment service and any routing rules will be skipped.
     */
    @JsonIgnore
    public JsonNullable<String> paymentServiceId() {
        return paymentServiceId;
    }

    /**
     * Marks the transaction as an AFT. Requires the payment service to support this feature, and might `recipient` and `buyer` data
     */
    @JsonIgnore
    public Optional<Boolean> accountFundingTransaction() {
        return accountFundingTransaction;
    }

    /**
     * Defines if the transaction will allow for a partial authorization.
     */
    @JsonIgnore
    public Optional<Boolean> allowPartialAuthorization() {
        return allowPartialAuthorization;
    }

    /**
     * The recipient of any account to account funding. For use with AFTs.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Recipient> recipient() {
        return (JsonNullable<Recipient>) recipient;
    }

    /**
     * The number of installments a buyer is required to make.
     */
    @JsonIgnore
    public JsonNullable<Long> installmentCount() {
        return installmentCount;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * The monetary amount for this transaction, in the smallest currency unit for the given currency, for example `1299` cents to create an authorization for `$12.99`. If the `intent` is set to `capture`, an amount greater than zero must be supplied. All gift card amounts are subtracted from this amount before the remainder is charged to the provided `payment_method`.
     */
    public TransactionCreate withAmount(long amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = amount;
        return this;
    }

    /**
     * A supported ISO 4217 currency code. For redirect requests, this value must match the one specified for `currency` in `payment_method`.
     */
    public TransactionCreate withCurrency(String currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = currency;
        return this;
    }

    /**
     * The 2-letter ISO code of the country where the transaction is processed. This is also used to filter the payment services that can process the transaction. If this value is provided for redirect requests and it's not `null`, it must match the one specified for `country` in `payment_method`. Otherwise, the value specified for `country` in `payment_method` will be assumed implicitly.
     */
    public TransactionCreate withCountry(String country) {
        Utils.checkNotNull(country, "country");
        this.country = JsonNullable.of(country);
        return this;
    }

    /**
     * The 2-letter ISO code of the country where the transaction is processed. This is also used to filter the payment services that can process the transaction. If this value is provided for redirect requests and it's not `null`, it must match the one specified for `country` in `payment_method`. Otherwise, the value specified for `country` in `payment_method` will be assumed implicitly.
     */
    public TransactionCreate withCountry(JsonNullable<String> country) {
        Utils.checkNotNull(country, "country");
        this.country = country;
        return this;
    }

    /**
     * The optional payment method to use for this transaction. This field is required if no `gift_cards` have been added.
     */
    public TransactionCreate withPaymentMethod(TransactionCreatePaymentMethod paymentMethod) {
        Utils.checkNotNull(paymentMethod, "paymentMethod");
        this.paymentMethod = JsonNullable.of(paymentMethod);
        return this;
    }

    /**
     * The optional payment method to use for this transaction. This field is required if no `gift_cards` have been added.
     */
    public TransactionCreate withPaymentMethod(JsonNullable<? extends TransactionCreatePaymentMethod> paymentMethod) {
        Utils.checkNotNull(paymentMethod, "paymentMethod");
        this.paymentMethod = paymentMethod;
        return this;
    }

    /**
     * Guest buyer details provided inline rather than creating a buyer resource beforehand and using the `buyer_id` or `buyer_external_identifier` keys. No buyer resource will be created on Gr4vy when used.
     */
    public TransactionCreate withBuyer(GuestBuyerInput buyer) {
        Utils.checkNotNull(buyer, "buyer");
        this.buyer = JsonNullable.of(buyer);
        return this;
    }

    /**
     * Guest buyer details provided inline rather than creating a buyer resource beforehand and using the `buyer_id` or `buyer_external_identifier` keys. No buyer resource will be created on Gr4vy when used.
     */
    public TransactionCreate withBuyer(JsonNullable<? extends GuestBuyerInput> buyer) {
        Utils.checkNotNull(buyer, "buyer");
        this.buyer = buyer;
        return this;
    }

    /**
     * The ID of the buyer to associate this payment method to. If this field is provided then the `buyer_external_identifier` field needs to be unset. If a stored payment method or gift card is provided, then the buyer for that payment method needs to match the buyer for this field.
     */
    public TransactionCreate withBuyerId(String buyerId) {
        Utils.checkNotNull(buyerId, "buyerId");
        this.buyerId = JsonNullable.of(buyerId);
        return this;
    }

    /**
     * The ID of the buyer to associate this payment method to. If this field is provided then the `buyer_external_identifier` field needs to be unset. If a stored payment method or gift card is provided, then the buyer for that payment method needs to match the buyer for this field.
     */
    public TransactionCreate withBuyerId(JsonNullable<String> buyerId) {
        Utils.checkNotNull(buyerId, "buyerId");
        this.buyerId = buyerId;
        return this;
    }

    /**
     * The `external_identifier` of the buyer to associate this payment method to. If this field is provided then the `buyer_id` field needs to be unset. If a stored payment method or gift card is provided, then the buyer for that payment method needs to match the buyer for this field.
     */
    public TransactionCreate withBuyerExternalIdentifier(String buyerExternalIdentifier) {
        Utils.checkNotNull(buyerExternalIdentifier, "buyerExternalIdentifier");
        this.buyerExternalIdentifier = JsonNullable.of(buyerExternalIdentifier);
        return this;
    }

    /**
     * The `external_identifier` of the buyer to associate this payment method to. If this field is provided then the `buyer_id` field needs to be unset. If a stored payment method or gift card is provided, then the buyer for that payment method needs to match the buyer for this field.
     */
    public TransactionCreate withBuyerExternalIdentifier(JsonNullable<String> buyerExternalIdentifier) {
        Utils.checkNotNull(buyerExternalIdentifier, "buyerExternalIdentifier");
        this.buyerExternalIdentifier = buyerExternalIdentifier;
        return this;
    }

    /**
     * The optional gift card(s) to use for this transaction. At least one gift card is required if no other `payment_method` has been added. By default, only a maximum limit of 10 gift cards may be used in a single transaction. Please contact our team to change this limit.
     */
    public TransactionCreate withGiftCards(List<GiftCardUnion> giftCards) {
        Utils.checkNotNull(giftCards, "giftCards");
        this.giftCards = JsonNullable.of(giftCards);
        return this;
    }

    /**
     * The optional gift card(s) to use for this transaction. At least one gift card is required if no other `payment_method` has been added. By default, only a maximum limit of 10 gift cards may be used in a single transaction. Please contact our team to change this limit.
     */
    public TransactionCreate withGiftCards(JsonNullable<? extends List<GiftCardUnion>> giftCards) {
        Utils.checkNotNull(giftCards, "giftCards");
        this.giftCards = giftCards;
        return this;
    }

    /**
     * An external identifier that can be used to match the transaction against your own records.
     */
    public TransactionCreate withExternalIdentifier(String externalIdentifier) {
        Utils.checkNotNull(externalIdentifier, "externalIdentifier");
        this.externalIdentifier = JsonNullable.of(externalIdentifier);
        return this;
    }

    /**
     * An external identifier that can be used to match the transaction against your own records.
     */
    public TransactionCreate withExternalIdentifier(JsonNullable<String> externalIdentifier) {
        Utils.checkNotNull(externalIdentifier, "externalIdentifier");
        this.externalIdentifier = externalIdentifier;
        return this;
    }

    public TransactionCreate withIntent(TransactionIntent intent) {
        Utils.checkNotNull(intent, "intent");
        this.intent = Optional.ofNullable(intent);
        return this;
    }

    public TransactionCreate withIntent(Optional<? extends TransactionIntent> intent) {
        Utils.checkNotNull(intent, "intent");
        this.intent = intent;
        return this;
    }

    /**
     * Whether or not to also try and store the payment method with us so that it can be used again for future use. This is only supported for payment methods that support this feature. There are also a few restrictions on how the flag may be set:
     * 
     * <p>* The flag has to be set to `true` when the `payment_source` is set to `recurring` or `installment`, and `merchant_initiated` is set to `false`.
     * * The flag has to be set to `false` (or not set) when using a previously vaulted payment method.
     */
    public TransactionCreate withStore(boolean store) {
        Utils.checkNotNull(store, "store");
        this.store = Optional.ofNullable(store);
        return this;
    }

    /**
     * Whether or not to also try and store the payment method with us so that it can be used again for future use. This is only supported for payment methods that support this feature. There are also a few restrictions on how the flag may be set:
     * 
     * <p>* The flag has to be set to `true` when the `payment_source` is set to `recurring` or `installment`, and `merchant_initiated` is set to `false`.
     * * The flag has to be set to `false` (or not set) when using a previously vaulted payment method.
     */
    public TransactionCreate withStore(Optional<Boolean> store) {
        Utils.checkNotNull(store, "store");
        this.store = store;
        return this;
    }

    /**
     * Pass through 3-D Secure data to support external 3-D Secure authorisation. If using an external 3-D Secure provider, you should not pass a `redirect_url` in the `payment_method` object for a transaction.
     */
    public TransactionCreate withThreeDSecureData(ThreeDSecureData threeDSecureData) {
        Utils.checkNotNull(threeDSecureData, "threeDSecureData");
        this.threeDSecureData = JsonNullable.of(threeDSecureData);
        return this;
    }

    /**
     * Pass through 3-D Secure data to support external 3-D Secure authorisation. If using an external 3-D Secure provider, you should not pass a `redirect_url` in the `payment_method` object for a transaction.
     */
    public TransactionCreate withThreeDSecureData(JsonNullable<? extends ThreeDSecureData> threeDSecureData) {
        Utils.checkNotNull(threeDSecureData, "threeDSecureData");
        this.threeDSecureData = threeDSecureData;
        return this;
    }

    /**
     * Any additional information about the transaction that you would like to store as key-value pairs. This data is passed to payment service providers that support it.
     */
    public TransactionCreate withMetadata(Map<String, String> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = JsonNullable.of(metadata);
        return this;
    }

    /**
     * Any additional information about the transaction that you would like to store as key-value pairs. This data is passed to payment service providers that support it.
     */
    public TransactionCreate withMetadata(JsonNullable<? extends Map<String, String>> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * Indicates whether the transaction represents a subsequent payment coming from a setup recurring payment. Please note there are some restrictions on how this flag may be used.
     * 
     * <p>The flag can only be `false` (or not set) when the transaction meets one of the following criteria:
     * 
     * <p>* It is not `merchant_initiated`.
     * * `payment_source` is set to `card_on_file`.
     * 
     * <p>The flag can only be set to `true` when the transaction meets one of the following criteria:
     * * It is not `merchant_initiated`.
     * * `payment_source` is set to `recurring` or `installment` and `merchant_initiated` is set to `true`.
     * * `payment_source` is set to `card_on_file`.
     */
    public TransactionCreate withIsSubsequentPayment(boolean isSubsequentPayment) {
        Utils.checkNotNull(isSubsequentPayment, "isSubsequentPayment");
        this.isSubsequentPayment = Optional.ofNullable(isSubsequentPayment);
        return this;
    }

    /**
     * Indicates whether the transaction represents a subsequent payment coming from a setup recurring payment. Please note there are some restrictions on how this flag may be used.
     * 
     * <p>The flag can only be `false` (or not set) when the transaction meets one of the following criteria:
     * 
     * <p>* It is not `merchant_initiated`.
     * * `payment_source` is set to `card_on_file`.
     * 
     * <p>The flag can only be set to `true` when the transaction meets one of the following criteria:
     * * It is not `merchant_initiated`.
     * * `payment_source` is set to `recurring` or `installment` and `merchant_initiated` is set to `true`.
     * * `payment_source` is set to `card_on_file`.
     */
    public TransactionCreate withIsSubsequentPayment(Optional<Boolean> isSubsequentPayment) {
        Utils.checkNotNull(isSubsequentPayment, "isSubsequentPayment");
        this.isSubsequentPayment = isSubsequentPayment;
        return this;
    }

    /**
     * Indicates whether the transaction was initiated by the merchant (true) or customer (false).
     */
    public TransactionCreate withMerchantInitiated(boolean merchantInitiated) {
        Utils.checkNotNull(merchantInitiated, "merchantInitiated");
        this.merchantInitiated = Optional.ofNullable(merchantInitiated);
        return this;
    }

    /**
     * Indicates whether the transaction was initiated by the merchant (true) or customer (false).
     */
    public TransactionCreate withMerchantInitiated(Optional<Boolean> merchantInitiated) {
        Utils.checkNotNull(merchantInitiated, "merchantInitiated");
        this.merchantInitiated = merchantInitiated;
        return this;
    }

    /**
     * The way payment method information made it to this transaction.
     */
    public TransactionCreate withPaymentSource(TransactionPaymentSource paymentSource) {
        Utils.checkNotNull(paymentSource, "paymentSource");
        this.paymentSource = Optional.ofNullable(paymentSource);
        return this;
    }

    /**
     * The way payment method information made it to this transaction.
     */
    public TransactionCreate withPaymentSource(Optional<? extends TransactionPaymentSource> paymentSource) {
        Utils.checkNotNull(paymentSource, "paymentSource");
        this.paymentSource = paymentSource;
        return this;
    }

    /**
     * The airline addendum data which describes the airline booking associated with this transaction.
     */
    public TransactionCreate withAirline(Airline airline) {
        Utils.checkNotNull(airline, "airline");
        this.airline = JsonNullable.of(airline);
        return this;
    }

    /**
     * The airline addendum data which describes the airline booking associated with this transaction.
     */
    public TransactionCreate withAirline(JsonNullable<? extends Airline> airline) {
        Utils.checkNotNull(airline, "airline");
        this.airline = airline;
        return this;
    }

    /**
     * An array of cart items that represents the line items of a transaction.
     */
    public TransactionCreate withCartItems(List<CartItem> cartItems) {
        Utils.checkNotNull(cartItems, "cartItems");
        this.cartItems = JsonNullable.of(cartItems);
        return this;
    }

    /**
     * An array of cart items that represents the line items of a transaction.
     */
    public TransactionCreate withCartItems(JsonNullable<? extends List<CartItem>> cartItems) {
        Utils.checkNotNull(cartItems, "cartItems");
        this.cartItems = cartItems;
        return this;
    }

    /**
     * Details about the payment and the merchant which may end up on the (bank) statement for the payment.
     */
    public TransactionCreate withStatementDescriptor(StatementDescriptor statementDescriptor) {
        Utils.checkNotNull(statementDescriptor, "statementDescriptor");
        this.statementDescriptor = JsonNullable.of(statementDescriptor);
        return this;
    }

    /**
     * Details about the payment and the merchant which may end up on the (bank) statement for the payment.
     */
    public TransactionCreate withStatementDescriptor(JsonNullable<? extends StatementDescriptor> statementDescriptor) {
        Utils.checkNotNull(statementDescriptor, "statementDescriptor");
        this.statementDescriptor = statementDescriptor;
        return this;
    }

    /**
     * A scheme's transaction identifier to use in connecting a merchant initiated transaction to a previous customer initiated transaction. If not provided, and a qualifying customer initiated transaction has been previously made with the stored payment method, then Gr4vy will populate this value with the identifier returned for that transaction. This field is also know as the Visa Transaction Identifier, or Mastercard Trace ID.
     */
    public TransactionCreate withPreviousSchemeTransactionId(String previousSchemeTransactionId) {
        Utils.checkNotNull(previousSchemeTransactionId, "previousSchemeTransactionId");
        this.previousSchemeTransactionId = JsonNullable.of(previousSchemeTransactionId);
        return this;
    }

    /**
     * A scheme's transaction identifier to use in connecting a merchant initiated transaction to a previous customer initiated transaction. If not provided, and a qualifying customer initiated transaction has been previously made with the stored payment method, then Gr4vy will populate this value with the identifier returned for that transaction. This field is also know as the Visa Transaction Identifier, or Mastercard Trace ID.
     */
    public TransactionCreate withPreviousSchemeTransactionId(JsonNullable<String> previousSchemeTransactionId) {
        Utils.checkNotNull(previousSchemeTransactionId, "previousSchemeTransactionId");
        this.previousSchemeTransactionId = previousSchemeTransactionId;
        return this;
    }

    /**
     * Information about the browser used by the buyer. This can be used by anti-fraud services.
     */
    public TransactionCreate withBrowserInfo(BrowserInfo browserInfo) {
        Utils.checkNotNull(browserInfo, "browserInfo");
        this.browserInfo = JsonNullable.of(browserInfo);
        return this;
    }

    /**
     * Information about the browser used by the buyer. This can be used by anti-fraud services.
     */
    public TransactionCreate withBrowserInfo(JsonNullable<? extends BrowserInfo> browserInfo) {
        Utils.checkNotNull(browserInfo, "browserInfo");
        this.browserInfo = browserInfo;
        return this;
    }

    /**
     * The unique identifier of a set of shipping details stored for the buyer. If provided, the created transaction will include a copy of the details at the point of transaction creation; i.e. it will not be affected by later changes to the detail in the database.
     */
    public TransactionCreate withShippingDetailsId(String shippingDetailsId) {
        Utils.checkNotNull(shippingDetailsId, "shippingDetailsId");
        this.shippingDetailsId = JsonNullable.of(shippingDetailsId);
        return this;
    }

    /**
     * The unique identifier of a set of shipping details stored for the buyer. If provided, the created transaction will include a copy of the details at the point of transaction creation; i.e. it will not be affected by later changes to the detail in the database.
     */
    public TransactionCreate withShippingDetailsId(JsonNullable<String> shippingDetailsId) {
        Utils.checkNotNull(shippingDetailsId, "shippingDetailsId");
        this.shippingDetailsId = shippingDetailsId;
        return this;
    }

    /**
     * Allows for passing optional configuration per connection to take advantage of connection specific features. When provided, the data is only passed to the target connection type to prevent sharing configuration across connections. Please note that each of the keys this object are in kebab-case, for example `cybersource-anti-fraud` as they represent the ID of the connector. All the other keys will be snake case, for example `merchant_defined_data` or camel case to match an external API that the connector uses.
     */
    public TransactionCreate withConnectionOptions(Map<String, Map<String, Object>> connectionOptions) {
        Utils.checkNotNull(connectionOptions, "connectionOptions");
        this.connectionOptions = JsonNullable.of(connectionOptions);
        return this;
    }

    /**
     * Allows for passing optional configuration per connection to take advantage of connection specific features. When provided, the data is only passed to the target connection type to prevent sharing configuration across connections. Please note that each of the keys this object are in kebab-case, for example `cybersource-anti-fraud` as they represent the ID of the connector. All the other keys will be snake case, for example `merchant_defined_data` or camel case to match an external API that the connector uses.
     */
    public TransactionCreate withConnectionOptions(JsonNullable<? extends Map<String, Map<String, Object>>> connectionOptions) {
        Utils.checkNotNull(connectionOptions, "connectionOptions");
        this.connectionOptions = connectionOptions;
        return this;
    }

    /**
     * Whether to capture the transaction asynchronously.
     * 
     * <p>- When `async_capture` is `false` (default), the transaction is captured in the same request.
     * - When `async_capture` is `true`, the transaction is automatically captured at a later time.
     * 
     * <p>Redirect transactions are not affected by this flag. This flag can only be set to `true` when `intent` is set to `capture`.
     */
    public TransactionCreate withAsyncCapture(boolean asyncCapture) {
        Utils.checkNotNull(asyncCapture, "asyncCapture");
        this.asyncCapture = Optional.ofNullable(asyncCapture);
        return this;
    }

    /**
     * Whether to capture the transaction asynchronously.
     * 
     * <p>- When `async_capture` is `false` (default), the transaction is captured in the same request.
     * - When `async_capture` is `true`, the transaction is automatically captured at a later time.
     * 
     * <p>Redirect transactions are not affected by this flag. This flag can only be set to `true` when `intent` is set to `capture`.
     */
    public TransactionCreate withAsyncCapture(Optional<Boolean> asyncCapture) {
        Utils.checkNotNull(asyncCapture, "asyncCapture");
        this.asyncCapture = asyncCapture;
        return this;
    }

    /**
     * This field represents the fingerprint data to be passed to the active anti-fraud service.
     */
    public TransactionCreate withAntiFraudFingerprint(String antiFraudFingerprint) {
        Utils.checkNotNull(antiFraudFingerprint, "antiFraudFingerprint");
        this.antiFraudFingerprint = JsonNullable.of(antiFraudFingerprint);
        return this;
    }

    /**
     * This field represents the fingerprint data to be passed to the active anti-fraud service.
     */
    public TransactionCreate withAntiFraudFingerprint(JsonNullable<String> antiFraudFingerprint) {
        Utils.checkNotNull(antiFraudFingerprint, "antiFraudFingerprint");
        this.antiFraudFingerprint = antiFraudFingerprint;
        return this;
    }

    /**
     * The unique identifier of an existing payment service. When provided, the created transaction will be processed by the given payment service and any routing rules will be skipped.
     */
    public TransactionCreate withPaymentServiceId(String paymentServiceId) {
        Utils.checkNotNull(paymentServiceId, "paymentServiceId");
        this.paymentServiceId = JsonNullable.of(paymentServiceId);
        return this;
    }

    /**
     * The unique identifier of an existing payment service. When provided, the created transaction will be processed by the given payment service and any routing rules will be skipped.
     */
    public TransactionCreate withPaymentServiceId(JsonNullable<String> paymentServiceId) {
        Utils.checkNotNull(paymentServiceId, "paymentServiceId");
        this.paymentServiceId = paymentServiceId;
        return this;
    }

    /**
     * Marks the transaction as an AFT. Requires the payment service to support this feature, and might `recipient` and `buyer` data
     */
    public TransactionCreate withAccountFundingTransaction(boolean accountFundingTransaction) {
        Utils.checkNotNull(accountFundingTransaction, "accountFundingTransaction");
        this.accountFundingTransaction = Optional.ofNullable(accountFundingTransaction);
        return this;
    }

    /**
     * Marks the transaction as an AFT. Requires the payment service to support this feature, and might `recipient` and `buyer` data
     */
    public TransactionCreate withAccountFundingTransaction(Optional<Boolean> accountFundingTransaction) {
        Utils.checkNotNull(accountFundingTransaction, "accountFundingTransaction");
        this.accountFundingTransaction = accountFundingTransaction;
        return this;
    }

    /**
     * Defines if the transaction will allow for a partial authorization.
     */
    public TransactionCreate withAllowPartialAuthorization(boolean allowPartialAuthorization) {
        Utils.checkNotNull(allowPartialAuthorization, "allowPartialAuthorization");
        this.allowPartialAuthorization = Optional.ofNullable(allowPartialAuthorization);
        return this;
    }

    /**
     * Defines if the transaction will allow for a partial authorization.
     */
    public TransactionCreate withAllowPartialAuthorization(Optional<Boolean> allowPartialAuthorization) {
        Utils.checkNotNull(allowPartialAuthorization, "allowPartialAuthorization");
        this.allowPartialAuthorization = allowPartialAuthorization;
        return this;
    }

    /**
     * The recipient of any account to account funding. For use with AFTs.
     */
    public TransactionCreate withRecipient(Recipient recipient) {
        Utils.checkNotNull(recipient, "recipient");
        this.recipient = JsonNullable.of(recipient);
        return this;
    }

    /**
     * The recipient of any account to account funding. For use with AFTs.
     */
    public TransactionCreate withRecipient(JsonNullable<? extends Recipient> recipient) {
        Utils.checkNotNull(recipient, "recipient");
        this.recipient = recipient;
        return this;
    }

    /**
     * The number of installments a buyer is required to make.
     */
    public TransactionCreate withInstallmentCount(long installmentCount) {
        Utils.checkNotNull(installmentCount, "installmentCount");
        this.installmentCount = JsonNullable.of(installmentCount);
        return this;
    }

    /**
     * The number of installments a buyer is required to make.
     */
    public TransactionCreate withInstallmentCount(JsonNullable<Long> installmentCount) {
        Utils.checkNotNull(installmentCount, "installmentCount");
        this.installmentCount = installmentCount;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        TransactionCreate other = (TransactionCreate) o;
        return 
            Objects.deepEquals(this.amount, other.amount) &&
            Objects.deepEquals(this.currency, other.currency) &&
            Objects.deepEquals(this.country, other.country) &&
            Objects.deepEquals(this.paymentMethod, other.paymentMethod) &&
            Objects.deepEquals(this.buyer, other.buyer) &&
            Objects.deepEquals(this.buyerId, other.buyerId) &&
            Objects.deepEquals(this.buyerExternalIdentifier, other.buyerExternalIdentifier) &&
            Objects.deepEquals(this.giftCards, other.giftCards) &&
            Objects.deepEquals(this.externalIdentifier, other.externalIdentifier) &&
            Objects.deepEquals(this.intent, other.intent) &&
            Objects.deepEquals(this.store, other.store) &&
            Objects.deepEquals(this.threeDSecureData, other.threeDSecureData) &&
            Objects.deepEquals(this.metadata, other.metadata) &&
            Objects.deepEquals(this.isSubsequentPayment, other.isSubsequentPayment) &&
            Objects.deepEquals(this.merchantInitiated, other.merchantInitiated) &&
            Objects.deepEquals(this.paymentSource, other.paymentSource) &&
            Objects.deepEquals(this.airline, other.airline) &&
            Objects.deepEquals(this.cartItems, other.cartItems) &&
            Objects.deepEquals(this.statementDescriptor, other.statementDescriptor) &&
            Objects.deepEquals(this.previousSchemeTransactionId, other.previousSchemeTransactionId) &&
            Objects.deepEquals(this.browserInfo, other.browserInfo) &&
            Objects.deepEquals(this.shippingDetailsId, other.shippingDetailsId) &&
            Objects.deepEquals(this.connectionOptions, other.connectionOptions) &&
            Objects.deepEquals(this.asyncCapture, other.asyncCapture) &&
            Objects.deepEquals(this.antiFraudFingerprint, other.antiFraudFingerprint) &&
            Objects.deepEquals(this.paymentServiceId, other.paymentServiceId) &&
            Objects.deepEquals(this.accountFundingTransaction, other.accountFundingTransaction) &&
            Objects.deepEquals(this.allowPartialAuthorization, other.allowPartialAuthorization) &&
            Objects.deepEquals(this.recipient, other.recipient) &&
            Objects.deepEquals(this.installmentCount, other.installmentCount);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            amount,
            currency,
            country,
            paymentMethod,
            buyer,
            buyerId,
            buyerExternalIdentifier,
            giftCards,
            externalIdentifier,
            intent,
            store,
            threeDSecureData,
            metadata,
            isSubsequentPayment,
            merchantInitiated,
            paymentSource,
            airline,
            cartItems,
            statementDescriptor,
            previousSchemeTransactionId,
            browserInfo,
            shippingDetailsId,
            connectionOptions,
            asyncCapture,
            antiFraudFingerprint,
            paymentServiceId,
            accountFundingTransaction,
            allowPartialAuthorization,
            recipient,
            installmentCount);
    }
    
    @Override
    public String toString() {
        return Utils.toString(TransactionCreate.class,
                "amount", amount,
                "currency", currency,
                "country", country,
                "paymentMethod", paymentMethod,
                "buyer", buyer,
                "buyerId", buyerId,
                "buyerExternalIdentifier", buyerExternalIdentifier,
                "giftCards", giftCards,
                "externalIdentifier", externalIdentifier,
                "intent", intent,
                "store", store,
                "threeDSecureData", threeDSecureData,
                "metadata", metadata,
                "isSubsequentPayment", isSubsequentPayment,
                "merchantInitiated", merchantInitiated,
                "paymentSource", paymentSource,
                "airline", airline,
                "cartItems", cartItems,
                "statementDescriptor", statementDescriptor,
                "previousSchemeTransactionId", previousSchemeTransactionId,
                "browserInfo", browserInfo,
                "shippingDetailsId", shippingDetailsId,
                "connectionOptions", connectionOptions,
                "asyncCapture", asyncCapture,
                "antiFraudFingerprint", antiFraudFingerprint,
                "paymentServiceId", paymentServiceId,
                "accountFundingTransaction", accountFundingTransaction,
                "allowPartialAuthorization", allowPartialAuthorization,
                "recipient", recipient,
                "installmentCount", installmentCount);
    }
    
    public final static class Builder {
 
        private Long amount;
 
        private String currency;
 
        private JsonNullable<String> country = JsonNullable.undefined();
 
        private JsonNullable<? extends TransactionCreatePaymentMethod> paymentMethod = JsonNullable.undefined();
 
        private JsonNullable<? extends GuestBuyerInput> buyer = JsonNullable.undefined();
 
        private JsonNullable<String> buyerId = JsonNullable.undefined();
 
        private JsonNullable<String> buyerExternalIdentifier = JsonNullable.undefined();
 
        private JsonNullable<? extends List<GiftCardUnion>> giftCards = JsonNullable.undefined();
 
        private JsonNullable<String> externalIdentifier = JsonNullable.undefined();
 
        private Optional<? extends TransactionIntent> intent = Optional.empty();
 
        private Optional<Boolean> store;
 
        private JsonNullable<? extends ThreeDSecureData> threeDSecureData = JsonNullable.undefined();
 
        private JsonNullable<? extends Map<String, String>> metadata = JsonNullable.undefined();
 
        private Optional<Boolean> isSubsequentPayment;
 
        private Optional<Boolean> merchantInitiated;
 
        private Optional<? extends TransactionPaymentSource> paymentSource = Optional.empty();
 
        private JsonNullable<? extends Airline> airline = JsonNullable.undefined();
 
        private JsonNullable<? extends List<CartItem>> cartItems = JsonNullable.undefined();
 
        private JsonNullable<? extends StatementDescriptor> statementDescriptor = JsonNullable.undefined();
 
        private JsonNullable<String> previousSchemeTransactionId = JsonNullable.undefined();
 
        private JsonNullable<? extends BrowserInfo> browserInfo = JsonNullable.undefined();
 
        private JsonNullable<String> shippingDetailsId = JsonNullable.undefined();
 
        private JsonNullable<? extends Map<String, Map<String, Object>>> connectionOptions = JsonNullable.undefined();
 
        private Optional<Boolean> asyncCapture;
 
        private JsonNullable<String> antiFraudFingerprint = JsonNullable.undefined();
 
        private JsonNullable<String> paymentServiceId = JsonNullable.undefined();
 
        private Optional<Boolean> accountFundingTransaction;
 
        private Optional<Boolean> allowPartialAuthorization;
 
        private JsonNullable<? extends Recipient> recipient = JsonNullable.undefined();
 
        private JsonNullable<Long> installmentCount = JsonNullable.undefined();
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The monetary amount for this transaction, in the smallest currency unit for the given currency, for example `1299` cents to create an authorization for `$12.99`. If the `intent` is set to `capture`, an amount greater than zero must be supplied. All gift card amounts are subtracted from this amount before the remainder is charged to the provided `payment_method`.
         */
        public Builder amount(long amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = amount;
            return this;
        }

        /**
         * A supported ISO 4217 currency code. For redirect requests, this value must match the one specified for `currency` in `payment_method`.
         */
        public Builder currency(String currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = currency;
            return this;
        }

        /**
         * The 2-letter ISO code of the country where the transaction is processed. This is also used to filter the payment services that can process the transaction. If this value is provided for redirect requests and it's not `null`, it must match the one specified for `country` in `payment_method`. Otherwise, the value specified for `country` in `payment_method` will be assumed implicitly.
         */
        public Builder country(String country) {
            Utils.checkNotNull(country, "country");
            this.country = JsonNullable.of(country);
            return this;
        }

        /**
         * The 2-letter ISO code of the country where the transaction is processed. This is also used to filter the payment services that can process the transaction. If this value is provided for redirect requests and it's not `null`, it must match the one specified for `country` in `payment_method`. Otherwise, the value specified for `country` in `payment_method` will be assumed implicitly.
         */
        public Builder country(JsonNullable<String> country) {
            Utils.checkNotNull(country, "country");
            this.country = country;
            return this;
        }

        /**
         * The optional payment method to use for this transaction. This field is required if no `gift_cards` have been added.
         */
        public Builder paymentMethod(TransactionCreatePaymentMethod paymentMethod) {
            Utils.checkNotNull(paymentMethod, "paymentMethod");
            this.paymentMethod = JsonNullable.of(paymentMethod);
            return this;
        }

        /**
         * The optional payment method to use for this transaction. This field is required if no `gift_cards` have been added.
         */
        public Builder paymentMethod(JsonNullable<? extends TransactionCreatePaymentMethod> paymentMethod) {
            Utils.checkNotNull(paymentMethod, "paymentMethod");
            this.paymentMethod = paymentMethod;
            return this;
        }

        /**
         * Guest buyer details provided inline rather than creating a buyer resource beforehand and using the `buyer_id` or `buyer_external_identifier` keys. No buyer resource will be created on Gr4vy when used.
         */
        public Builder buyer(GuestBuyerInput buyer) {
            Utils.checkNotNull(buyer, "buyer");
            this.buyer = JsonNullable.of(buyer);
            return this;
        }

        /**
         * Guest buyer details provided inline rather than creating a buyer resource beforehand and using the `buyer_id` or `buyer_external_identifier` keys. No buyer resource will be created on Gr4vy when used.
         */
        public Builder buyer(JsonNullable<? extends GuestBuyerInput> buyer) {
            Utils.checkNotNull(buyer, "buyer");
            this.buyer = buyer;
            return this;
        }

        /**
         * The ID of the buyer to associate this payment method to. If this field is provided then the `buyer_external_identifier` field needs to be unset. If a stored payment method or gift card is provided, then the buyer for that payment method needs to match the buyer for this field.
         */
        public Builder buyerId(String buyerId) {
            Utils.checkNotNull(buyerId, "buyerId");
            this.buyerId = JsonNullable.of(buyerId);
            return this;
        }

        /**
         * The ID of the buyer to associate this payment method to. If this field is provided then the `buyer_external_identifier` field needs to be unset. If a stored payment method or gift card is provided, then the buyer for that payment method needs to match the buyer for this field.
         */
        public Builder buyerId(JsonNullable<String> buyerId) {
            Utils.checkNotNull(buyerId, "buyerId");
            this.buyerId = buyerId;
            return this;
        }

        /**
         * The `external_identifier` of the buyer to associate this payment method to. If this field is provided then the `buyer_id` field needs to be unset. If a stored payment method or gift card is provided, then the buyer for that payment method needs to match the buyer for this field.
         */
        public Builder buyerExternalIdentifier(String buyerExternalIdentifier) {
            Utils.checkNotNull(buyerExternalIdentifier, "buyerExternalIdentifier");
            this.buyerExternalIdentifier = JsonNullable.of(buyerExternalIdentifier);
            return this;
        }

        /**
         * The `external_identifier` of the buyer to associate this payment method to. If this field is provided then the `buyer_id` field needs to be unset. If a stored payment method or gift card is provided, then the buyer for that payment method needs to match the buyer for this field.
         */
        public Builder buyerExternalIdentifier(JsonNullable<String> buyerExternalIdentifier) {
            Utils.checkNotNull(buyerExternalIdentifier, "buyerExternalIdentifier");
            this.buyerExternalIdentifier = buyerExternalIdentifier;
            return this;
        }

        /**
         * The optional gift card(s) to use for this transaction. At least one gift card is required if no other `payment_method` has been added. By default, only a maximum limit of 10 gift cards may be used in a single transaction. Please contact our team to change this limit.
         */
        public Builder giftCards(List<GiftCardUnion> giftCards) {
            Utils.checkNotNull(giftCards, "giftCards");
            this.giftCards = JsonNullable.of(giftCards);
            return this;
        }

        /**
         * The optional gift card(s) to use for this transaction. At least one gift card is required if no other `payment_method` has been added. By default, only a maximum limit of 10 gift cards may be used in a single transaction. Please contact our team to change this limit.
         */
        public Builder giftCards(JsonNullable<? extends List<GiftCardUnion>> giftCards) {
            Utils.checkNotNull(giftCards, "giftCards");
            this.giftCards = giftCards;
            return this;
        }

        /**
         * An external identifier that can be used to match the transaction against your own records.
         */
        public Builder externalIdentifier(String externalIdentifier) {
            Utils.checkNotNull(externalIdentifier, "externalIdentifier");
            this.externalIdentifier = JsonNullable.of(externalIdentifier);
            return this;
        }

        /**
         * An external identifier that can be used to match the transaction against your own records.
         */
        public Builder externalIdentifier(JsonNullable<String> externalIdentifier) {
            Utils.checkNotNull(externalIdentifier, "externalIdentifier");
            this.externalIdentifier = externalIdentifier;
            return this;
        }

        public Builder intent(TransactionIntent intent) {
            Utils.checkNotNull(intent, "intent");
            this.intent = Optional.ofNullable(intent);
            return this;
        }

        public Builder intent(Optional<? extends TransactionIntent> intent) {
            Utils.checkNotNull(intent, "intent");
            this.intent = intent;
            return this;
        }

        /**
         * Whether or not to also try and store the payment method with us so that it can be used again for future use. This is only supported for payment methods that support this feature. There are also a few restrictions on how the flag may be set:
         * 
         * <p>* The flag has to be set to `true` when the `payment_source` is set to `recurring` or `installment`, and `merchant_initiated` is set to `false`.
         * * The flag has to be set to `false` (or not set) when using a previously vaulted payment method.
         */
        public Builder store(boolean store) {
            Utils.checkNotNull(store, "store");
            this.store = Optional.ofNullable(store);
            return this;
        }

        /**
         * Whether or not to also try and store the payment method with us so that it can be used again for future use. This is only supported for payment methods that support this feature. There are also a few restrictions on how the flag may be set:
         * 
         * <p>* The flag has to be set to `true` when the `payment_source` is set to `recurring` or `installment`, and `merchant_initiated` is set to `false`.
         * * The flag has to be set to `false` (or not set) when using a previously vaulted payment method.
         */
        public Builder store(Optional<Boolean> store) {
            Utils.checkNotNull(store, "store");
            this.store = store;
            return this;
        }

        /**
         * Pass through 3-D Secure data to support external 3-D Secure authorisation. If using an external 3-D Secure provider, you should not pass a `redirect_url` in the `payment_method` object for a transaction.
         */
        public Builder threeDSecureData(ThreeDSecureData threeDSecureData) {
            Utils.checkNotNull(threeDSecureData, "threeDSecureData");
            this.threeDSecureData = JsonNullable.of(threeDSecureData);
            return this;
        }

        /**
         * Pass through 3-D Secure data to support external 3-D Secure authorisation. If using an external 3-D Secure provider, you should not pass a `redirect_url` in the `payment_method` object for a transaction.
         */
        public Builder threeDSecureData(JsonNullable<? extends ThreeDSecureData> threeDSecureData) {
            Utils.checkNotNull(threeDSecureData, "threeDSecureData");
            this.threeDSecureData = threeDSecureData;
            return this;
        }

        /**
         * Any additional information about the transaction that you would like to store as key-value pairs. This data is passed to payment service providers that support it.
         */
        public Builder metadata(Map<String, String> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = JsonNullable.of(metadata);
            return this;
        }

        /**
         * Any additional information about the transaction that you would like to store as key-value pairs. This data is passed to payment service providers that support it.
         */
        public Builder metadata(JsonNullable<? extends Map<String, String>> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }

        /**
         * Indicates whether the transaction represents a subsequent payment coming from a setup recurring payment. Please note there are some restrictions on how this flag may be used.
         * 
         * <p>The flag can only be `false` (or not set) when the transaction meets one of the following criteria:
         * 
         * <p>* It is not `merchant_initiated`.
         * * `payment_source` is set to `card_on_file`.
         * 
         * <p>The flag can only be set to `true` when the transaction meets one of the following criteria:
         * * It is not `merchant_initiated`.
         * * `payment_source` is set to `recurring` or `installment` and `merchant_initiated` is set to `true`.
         * * `payment_source` is set to `card_on_file`.
         */
        public Builder isSubsequentPayment(boolean isSubsequentPayment) {
            Utils.checkNotNull(isSubsequentPayment, "isSubsequentPayment");
            this.isSubsequentPayment = Optional.ofNullable(isSubsequentPayment);
            return this;
        }

        /**
         * Indicates whether the transaction represents a subsequent payment coming from a setup recurring payment. Please note there are some restrictions on how this flag may be used.
         * 
         * <p>The flag can only be `false` (or not set) when the transaction meets one of the following criteria:
         * 
         * <p>* It is not `merchant_initiated`.
         * * `payment_source` is set to `card_on_file`.
         * 
         * <p>The flag can only be set to `true` when the transaction meets one of the following criteria:
         * * It is not `merchant_initiated`.
         * * `payment_source` is set to `recurring` or `installment` and `merchant_initiated` is set to `true`.
         * * `payment_source` is set to `card_on_file`.
         */
        public Builder isSubsequentPayment(Optional<Boolean> isSubsequentPayment) {
            Utils.checkNotNull(isSubsequentPayment, "isSubsequentPayment");
            this.isSubsequentPayment = isSubsequentPayment;
            return this;
        }

        /**
         * Indicates whether the transaction was initiated by the merchant (true) or customer (false).
         */
        public Builder merchantInitiated(boolean merchantInitiated) {
            Utils.checkNotNull(merchantInitiated, "merchantInitiated");
            this.merchantInitiated = Optional.ofNullable(merchantInitiated);
            return this;
        }

        /**
         * Indicates whether the transaction was initiated by the merchant (true) or customer (false).
         */
        public Builder merchantInitiated(Optional<Boolean> merchantInitiated) {
            Utils.checkNotNull(merchantInitiated, "merchantInitiated");
            this.merchantInitiated = merchantInitiated;
            return this;
        }

        /**
         * The way payment method information made it to this transaction.
         */
        public Builder paymentSource(TransactionPaymentSource paymentSource) {
            Utils.checkNotNull(paymentSource, "paymentSource");
            this.paymentSource = Optional.ofNullable(paymentSource);
            return this;
        }

        /**
         * The way payment method information made it to this transaction.
         */
        public Builder paymentSource(Optional<? extends TransactionPaymentSource> paymentSource) {
            Utils.checkNotNull(paymentSource, "paymentSource");
            this.paymentSource = paymentSource;
            return this;
        }

        /**
         * The airline addendum data which describes the airline booking associated with this transaction.
         */
        public Builder airline(Airline airline) {
            Utils.checkNotNull(airline, "airline");
            this.airline = JsonNullable.of(airline);
            return this;
        }

        /**
         * The airline addendum data which describes the airline booking associated with this transaction.
         */
        public Builder airline(JsonNullable<? extends Airline> airline) {
            Utils.checkNotNull(airline, "airline");
            this.airline = airline;
            return this;
        }

        /**
         * An array of cart items that represents the line items of a transaction.
         */
        public Builder cartItems(List<CartItem> cartItems) {
            Utils.checkNotNull(cartItems, "cartItems");
            this.cartItems = JsonNullable.of(cartItems);
            return this;
        }

        /**
         * An array of cart items that represents the line items of a transaction.
         */
        public Builder cartItems(JsonNullable<? extends List<CartItem>> cartItems) {
            Utils.checkNotNull(cartItems, "cartItems");
            this.cartItems = cartItems;
            return this;
        }

        /**
         * Details about the payment and the merchant which may end up on the (bank) statement for the payment.
         */
        public Builder statementDescriptor(StatementDescriptor statementDescriptor) {
            Utils.checkNotNull(statementDescriptor, "statementDescriptor");
            this.statementDescriptor = JsonNullable.of(statementDescriptor);
            return this;
        }

        /**
         * Details about the payment and the merchant which may end up on the (bank) statement for the payment.
         */
        public Builder statementDescriptor(JsonNullable<? extends StatementDescriptor> statementDescriptor) {
            Utils.checkNotNull(statementDescriptor, "statementDescriptor");
            this.statementDescriptor = statementDescriptor;
            return this;
        }

        /**
         * A scheme's transaction identifier to use in connecting a merchant initiated transaction to a previous customer initiated transaction. If not provided, and a qualifying customer initiated transaction has been previously made with the stored payment method, then Gr4vy will populate this value with the identifier returned for that transaction. This field is also know as the Visa Transaction Identifier, or Mastercard Trace ID.
         */
        public Builder previousSchemeTransactionId(String previousSchemeTransactionId) {
            Utils.checkNotNull(previousSchemeTransactionId, "previousSchemeTransactionId");
            this.previousSchemeTransactionId = JsonNullable.of(previousSchemeTransactionId);
            return this;
        }

        /**
         * A scheme's transaction identifier to use in connecting a merchant initiated transaction to a previous customer initiated transaction. If not provided, and a qualifying customer initiated transaction has been previously made with the stored payment method, then Gr4vy will populate this value with the identifier returned for that transaction. This field is also know as the Visa Transaction Identifier, or Mastercard Trace ID.
         */
        public Builder previousSchemeTransactionId(JsonNullable<String> previousSchemeTransactionId) {
            Utils.checkNotNull(previousSchemeTransactionId, "previousSchemeTransactionId");
            this.previousSchemeTransactionId = previousSchemeTransactionId;
            return this;
        }

        /**
         * Information about the browser used by the buyer. This can be used by anti-fraud services.
         */
        public Builder browserInfo(BrowserInfo browserInfo) {
            Utils.checkNotNull(browserInfo, "browserInfo");
            this.browserInfo = JsonNullable.of(browserInfo);
            return this;
        }

        /**
         * Information about the browser used by the buyer. This can be used by anti-fraud services.
         */
        public Builder browserInfo(JsonNullable<? extends BrowserInfo> browserInfo) {
            Utils.checkNotNull(browserInfo, "browserInfo");
            this.browserInfo = browserInfo;
            return this;
        }

        /**
         * The unique identifier of a set of shipping details stored for the buyer. If provided, the created transaction will include a copy of the details at the point of transaction creation; i.e. it will not be affected by later changes to the detail in the database.
         */
        public Builder shippingDetailsId(String shippingDetailsId) {
            Utils.checkNotNull(shippingDetailsId, "shippingDetailsId");
            this.shippingDetailsId = JsonNullable.of(shippingDetailsId);
            return this;
        }

        /**
         * The unique identifier of a set of shipping details stored for the buyer. If provided, the created transaction will include a copy of the details at the point of transaction creation; i.e. it will not be affected by later changes to the detail in the database.
         */
        public Builder shippingDetailsId(JsonNullable<String> shippingDetailsId) {
            Utils.checkNotNull(shippingDetailsId, "shippingDetailsId");
            this.shippingDetailsId = shippingDetailsId;
            return this;
        }

        /**
         * Allows for passing optional configuration per connection to take advantage of connection specific features. When provided, the data is only passed to the target connection type to prevent sharing configuration across connections. Please note that each of the keys this object are in kebab-case, for example `cybersource-anti-fraud` as they represent the ID of the connector. All the other keys will be snake case, for example `merchant_defined_data` or camel case to match an external API that the connector uses.
         */
        public Builder connectionOptions(Map<String, Map<String, Object>> connectionOptions) {
            Utils.checkNotNull(connectionOptions, "connectionOptions");
            this.connectionOptions = JsonNullable.of(connectionOptions);
            return this;
        }

        /**
         * Allows for passing optional configuration per connection to take advantage of connection specific features. When provided, the data is only passed to the target connection type to prevent sharing configuration across connections. Please note that each of the keys this object are in kebab-case, for example `cybersource-anti-fraud` as they represent the ID of the connector. All the other keys will be snake case, for example `merchant_defined_data` or camel case to match an external API that the connector uses.
         */
        public Builder connectionOptions(JsonNullable<? extends Map<String, Map<String, Object>>> connectionOptions) {
            Utils.checkNotNull(connectionOptions, "connectionOptions");
            this.connectionOptions = connectionOptions;
            return this;
        }

        /**
         * Whether to capture the transaction asynchronously.
         * 
         * <p>- When `async_capture` is `false` (default), the transaction is captured in the same request.
         * - When `async_capture` is `true`, the transaction is automatically captured at a later time.
         * 
         * <p>Redirect transactions are not affected by this flag. This flag can only be set to `true` when `intent` is set to `capture`.
         */
        public Builder asyncCapture(boolean asyncCapture) {
            Utils.checkNotNull(asyncCapture, "asyncCapture");
            this.asyncCapture = Optional.ofNullable(asyncCapture);
            return this;
        }

        /**
         * Whether to capture the transaction asynchronously.
         * 
         * <p>- When `async_capture` is `false` (default), the transaction is captured in the same request.
         * - When `async_capture` is `true`, the transaction is automatically captured at a later time.
         * 
         * <p>Redirect transactions are not affected by this flag. This flag can only be set to `true` when `intent` is set to `capture`.
         */
        public Builder asyncCapture(Optional<Boolean> asyncCapture) {
            Utils.checkNotNull(asyncCapture, "asyncCapture");
            this.asyncCapture = asyncCapture;
            return this;
        }

        /**
         * This field represents the fingerprint data to be passed to the active anti-fraud service.
         */
        public Builder antiFraudFingerprint(String antiFraudFingerprint) {
            Utils.checkNotNull(antiFraudFingerprint, "antiFraudFingerprint");
            this.antiFraudFingerprint = JsonNullable.of(antiFraudFingerprint);
            return this;
        }

        /**
         * This field represents the fingerprint data to be passed to the active anti-fraud service.
         */
        public Builder antiFraudFingerprint(JsonNullable<String> antiFraudFingerprint) {
            Utils.checkNotNull(antiFraudFingerprint, "antiFraudFingerprint");
            this.antiFraudFingerprint = antiFraudFingerprint;
            return this;
        }

        /**
         * The unique identifier of an existing payment service. When provided, the created transaction will be processed by the given payment service and any routing rules will be skipped.
         */
        public Builder paymentServiceId(String paymentServiceId) {
            Utils.checkNotNull(paymentServiceId, "paymentServiceId");
            this.paymentServiceId = JsonNullable.of(paymentServiceId);
            return this;
        }

        /**
         * The unique identifier of an existing payment service. When provided, the created transaction will be processed by the given payment service and any routing rules will be skipped.
         */
        public Builder paymentServiceId(JsonNullable<String> paymentServiceId) {
            Utils.checkNotNull(paymentServiceId, "paymentServiceId");
            this.paymentServiceId = paymentServiceId;
            return this;
        }

        /**
         * Marks the transaction as an AFT. Requires the payment service to support this feature, and might `recipient` and `buyer` data
         */
        public Builder accountFundingTransaction(boolean accountFundingTransaction) {
            Utils.checkNotNull(accountFundingTransaction, "accountFundingTransaction");
            this.accountFundingTransaction = Optional.ofNullable(accountFundingTransaction);
            return this;
        }

        /**
         * Marks the transaction as an AFT. Requires the payment service to support this feature, and might `recipient` and `buyer` data
         */
        public Builder accountFundingTransaction(Optional<Boolean> accountFundingTransaction) {
            Utils.checkNotNull(accountFundingTransaction, "accountFundingTransaction");
            this.accountFundingTransaction = accountFundingTransaction;
            return this;
        }

        /**
         * Defines if the transaction will allow for a partial authorization.
         */
        public Builder allowPartialAuthorization(boolean allowPartialAuthorization) {
            Utils.checkNotNull(allowPartialAuthorization, "allowPartialAuthorization");
            this.allowPartialAuthorization = Optional.ofNullable(allowPartialAuthorization);
            return this;
        }

        /**
         * Defines if the transaction will allow for a partial authorization.
         */
        public Builder allowPartialAuthorization(Optional<Boolean> allowPartialAuthorization) {
            Utils.checkNotNull(allowPartialAuthorization, "allowPartialAuthorization");
            this.allowPartialAuthorization = allowPartialAuthorization;
            return this;
        }

        /**
         * The recipient of any account to account funding. For use with AFTs.
         */
        public Builder recipient(Recipient recipient) {
            Utils.checkNotNull(recipient, "recipient");
            this.recipient = JsonNullable.of(recipient);
            return this;
        }

        /**
         * The recipient of any account to account funding. For use with AFTs.
         */
        public Builder recipient(JsonNullable<? extends Recipient> recipient) {
            Utils.checkNotNull(recipient, "recipient");
            this.recipient = recipient;
            return this;
        }

        /**
         * The number of installments a buyer is required to make.
         */
        public Builder installmentCount(long installmentCount) {
            Utils.checkNotNull(installmentCount, "installmentCount");
            this.installmentCount = JsonNullable.of(installmentCount);
            return this;
        }

        /**
         * The number of installments a buyer is required to make.
         */
        public Builder installmentCount(JsonNullable<Long> installmentCount) {
            Utils.checkNotNull(installmentCount, "installmentCount");
            this.installmentCount = installmentCount;
            return this;
        }
        
        public TransactionCreate build() {
            if (store == null) {
                store = _SINGLETON_VALUE_Store.value();
            }
            if (isSubsequentPayment == null) {
                isSubsequentPayment = _SINGLETON_VALUE_IsSubsequentPayment.value();
            }
            if (merchantInitiated == null) {
                merchantInitiated = _SINGLETON_VALUE_MerchantInitiated.value();
            }
            if (asyncCapture == null) {
                asyncCapture = _SINGLETON_VALUE_AsyncCapture.value();
            }
            if (accountFundingTransaction == null) {
                accountFundingTransaction = _SINGLETON_VALUE_AccountFundingTransaction.value();
            }
            if (allowPartialAuthorization == null) {
                allowPartialAuthorization = _SINGLETON_VALUE_AllowPartialAuthorization.value();
            }
            return new TransactionCreate(
                amount,
                currency,
                country,
                paymentMethod,
                buyer,
                buyerId,
                buyerExternalIdentifier,
                giftCards,
                externalIdentifier,
                intent,
                store,
                threeDSecureData,
                metadata,
                isSubsequentPayment,
                merchantInitiated,
                paymentSource,
                airline,
                cartItems,
                statementDescriptor,
                previousSchemeTransactionId,
                browserInfo,
                shippingDetailsId,
                connectionOptions,
                asyncCapture,
                antiFraudFingerprint,
                paymentServiceId,
                accountFundingTransaction,
                allowPartialAuthorization,
                recipient,
                installmentCount);
        }

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_Store =
                new LazySingletonValue<>(
                        "store",
                        "false",
                        new TypeReference<Optional<Boolean>>() {});

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_IsSubsequentPayment =
                new LazySingletonValue<>(
                        "is_subsequent_payment",
                        "false",
                        new TypeReference<Optional<Boolean>>() {});

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_MerchantInitiated =
                new LazySingletonValue<>(
                        "merchant_initiated",
                        "false",
                        new TypeReference<Optional<Boolean>>() {});

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_AsyncCapture =
                new LazySingletonValue<>(
                        "async_capture",
                        "false",
                        new TypeReference<Optional<Boolean>>() {});

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_AccountFundingTransaction =
                new LazySingletonValue<>(
                        "account_funding_transaction",
                        "false",
                        new TypeReference<Optional<Boolean>>() {});

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_AllowPartialAuthorization =
                new LazySingletonValue<>(
                        "allow_partial_authorization",
                        "false",
                        new TypeReference<Optional<Boolean>>() {});
    }
}
